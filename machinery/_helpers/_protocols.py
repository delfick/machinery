from __future__ import annotations

import asyncio
import types
from collections.abc import AsyncGenerator, Callable, Coroutine, Iterable, Iterator
from typing import TYPE_CHECKING, Any, Literal, Protocol, Self, cast


class FutureStatus[T_Ret](Protocol):
    def done(self) -> bool: ...
    def result(self) -> T_Ret: ...
    def exception(self) -> BaseException | None: ...
    def cancelled(self) -> bool: ...


class FutureCallback[T_Ret](Protocol):
    def __hash__(self) -> int: ...
    def __call__(self, res: FutureStatus[T_Ret], /) -> None: ...


class FutureCTXCallback[T_Ret, T_Tramp: Tramp = Tramp](Protocol):
    def __hash__(self) -> int: ...
    def __call__(self, ctx: CTX[T_Tramp], res: FutureStatus[T_Ret], /) -> None: ...


class Reporter[T_Ret](Protocol):
    def __call__(self, res: FutureStatus[T_Ret]) -> Literal[True] | None: ...


class WaitByCallback[T_Ret](Protocol):
    def done(self) -> bool: ...
    def cancel(self) -> bool: ...
    def add_done_callback(
        self, cb: Callable[[FutureStatus[T_Ret]], None]
    ) -> None | FutureCallback[T_Ret]: ...
    def remove_done_callback(self, cb: Callable[[FutureStatus[T_Ret]], None]) -> int: ...


class WithRepr(Protocol):
    def __repr__(self) -> str: ...


class Tramp(Protocol):
    def set_future_name(self, fut: asyncio.Future[Any], *, name: str) -> None: ...
    def get_future_name(self, fut: asyncio.Future[Any]) -> str | None: ...
    def log_info(self, msg: str) -> None: ...
    def log_exception(
        self,
        msg: object,
        *,
        exc_info: tuple[type[BaseException], BaseException, types.TracebackType] | None = None,
    ) -> None: ...

    def fut_to_string(self, f: asyncio.Future[Any] | WithRepr, with_name: bool = True) -> str: ...

    @property
    def reporter(self) -> Reporter[Any]: ...

    @property
    def silent_reporter(self) -> Reporter[Any]: ...


class CTX[T_Tramp: Tramp = Tramp](Protocol):
    @property
    def loop(self) -> asyncio.AbstractEventLoop: ...

    @property
    def name(self) -> str: ...

    @property
    def tramp(self) -> T_Tramp: ...

    def set_exception(self, exc: BaseException) -> None: ...

    def add_on_done(
        self,
        cb: FutureCTXCallback[None, T_Tramp],
        index: FutureCallback[None] | None = None,
    ) -> FutureCallback[None]: ...

    def done(self) -> bool: ...
    def cancel(self) -> bool: ...
    def exception(self) -> BaseException | None: ...
    def cancelled(self) -> bool: ...

    def add_done_callback(
        self, cb: Callable[[FutureStatus[None]], None]
    ) -> FutureCallback[None]: ...
    def remove_done_callback(self, cb: Callable[[FutureStatus[None]], None]) -> int: ...

    def has_direct_done_callback(self, cb: Callable[[FutureStatus[None]], None]) -> bool: ...

    async def wait_for_first(self, *futs: WaitByCallback[Any] | asyncio.Event) -> None: ...

    async def wait_for_all(self, *futs: WaitByCallback[Any] | asyncio.Event) -> None: ...

    async def async_with_timeout[T_Ret](
        self,
        coro: Coroutine[object, object, T_Ret],
        *,
        name: str,
        silent: bool = True,
        timeout: int = 10,
        timeout_error: BaseException | None = None,
    ) -> T_Ret: ...

    def async_as_background[T_Ret](
        self, coro: Coroutine[object, object, T_Ret], *, silent: bool = True
    ) -> asyncio.Task[T_Ret]: ...

    def child(self, *, name: str, prefix: str = "") -> Self: ...

    def __enter__(self) -> Self: ...

    def __exit__(
        self,
        exc_type: type[BaseException] | None,
        value: BaseException | None,
        tb: types.TracebackType | None,
    ) -> None: ...


class TaskHolder(Protocol):
    def add_coroutine[T_Ret](
        self, coro: Coroutine[object, object, T_Ret], *, silent: bool = False
    ) -> asyncio.Task[T_Ret]: ...

    def add_task[T_Ret](self, task: asyncio.Task[T_Ret]) -> asyncio.Task[T_Ret]: ...

    @property
    def pending(self) -> int: ...

    def __contains__(self, task: asyncio.Task[object]) -> bool: ...

    def __iter__(self) -> Iterator[WaitByCallback[object]]: ...


class SyncQueue[T_Item = object](Protocol):
    def is_empty(self) -> bool: ...

    def __len__(self) -> int: ...

    def append(self, item: T_Item) -> None: ...

    def __iter__(self) -> Iterator[T_Item]: ...

    def get_all(self) -> Iterator[T_Item]: ...

    def remaining(self) -> Iterator[T_Item]: ...


class LimitedQueue[T_Item = object](Protocol):
    @property
    def breaker(self) -> asyncio.Event: ...

    def is_empty(self) -> bool: ...

    def __len__(self) -> int: ...

    def append(self, item: T_Item, *, priority: bool = False) -> None: ...

    def add_done_callback(
        self, cb: Callable[[FutureStatus[None]], None]
    ) -> FutureCallback[None]: ...


class QueueItemDef[T_Item](Protocol):
    def __call__(self, o: object) -> T_Item: ...


class Queue[T_Item = object](Protocol):
    @property
    def breaker(self) -> asyncio.Event: ...

    def is_empty(self) -> bool: ...

    def __len__(self) -> int: ...

    def process_after_yielded(
        self, process: Callable[[LimitedQueue[T_Item]], None], /
    ) -> None: ...

    def append(self, item: T_Item, *, priority: bool = False) -> None: ...

    def append_instruction(self, cb: Callable[[], None], *, priority: bool = False) -> None: ...

    def __aiter__(self) -> AsyncGenerator[T_Item]: ...

    @property
    def get_all(self) -> Callable[[], AsyncGenerator[T_Item]]: ...

    def remaining(self) -> Iterator[T_Item]: ...

    def add_done_callback(
        self, cb: Callable[[FutureStatus[None]], None]
    ) -> FutureCallback[None]: ...


class QueueFeeder[T_QueueContext](Protocol):
    def set_as_finished_if_out_of_sources(self) -> None: ...

    def add_sync_function(
        self, func: Callable[[], object], *, context: T_QueueContext | None = None
    ) -> None: ...

    def add_sync_iterator(
        self,
        iterator: Iterable[object] | Iterator[object],
        *,
        context: T_QueueContext | None = None,
    ) -> None: ...

    def add_value(self, value: object, *, context: T_QueueContext | None = None) -> None: ...

    def add_coroutine(
        self, coro: Coroutine[object, object, object], *, context: T_QueueContext | None = None
    ) -> None: ...

    def add_task(
        self, task: asyncio.Task[object], *, context: T_QueueContext | None = None
    ) -> None: ...

    def add_async_generator(
        self, agen: AsyncGenerator[object], *, context: T_QueueContext | None = None
    ) -> None: ...


class Streamer[T_Item](Protocol):
    @property
    def breaker(self) -> asyncio.Event: ...

    def __aiter__(self) -> AsyncGenerator[T_Item]: ...

    def remaining(self) -> Iterator[T_Item]: ...


class Ticker(Protocol):
    @property
    def pauser(self) -> asyncio.Semaphore | None: ...

    def __aiter__(self) -> AsyncGenerator[tuple[int, float]]: ...

    def change_after(self, every: int, *, set_new_every: bool = True) -> None: ...


if TYPE_CHECKING:
    _FS: FutureStatus[None] = cast(asyncio.Future[None], None)
    _WBC: WaitByCallback[None] = cast(asyncio.Future[None], None)
    cast(asyncio.Future[None], None).add_done_callback(cast(FutureCallback[None], None))
